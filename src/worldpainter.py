import os
import subprocess
from pathlib import Path
import logging
import numpy as np
from PIL import Image

log = logging.getLogger(__name__)

class WorldPainterInterface:
    def __init__(self, config={}):
        self.config = config

    def _to_wp_path(self, path):
        """Converts local path to an absolute string with forward slashes for JS."""
        # Ensure it is a string before passing to Path
        path_str = str(path)
        return str(Path(path_str).resolve()).replace('\\', '/')

    def split_biomes(self, biome_map_path, output_dir):
        """Splits a multi-value biome map into separate binary masks for each biome."""
        if not biome_map_path or not os.path.exists(biome_map_path):
            return {}
        
        try:
            # Need rasterio for resizing or PIL
            # Using PIL since visualize.py uses it and we know it's there
            img = Image.open(biome_map_path)
            data = np.array(img)
            
            biomes_found = {}
            unique_biomes = np.unique(data)
            
            for bid in unique_biomes:
                # Simply use the ID as the key
                valid_bid = int(bid)
                
                mask = (data == bid).astype(np.uint8) * 255
                mask_img = Image.fromarray(mask, mode='L')
                
                filename = f"biome_{valid_bid}.png"
                out_path = Path(output_dir) / filename
                mask_img.save(out_path)
                biomes_found[valid_bid] = str(out_path)
                
            return biomes_found
        except Exception as e:
            log.error(f"Failed to split biomes: {e}")
            return {}

    def _get_wp_biome_name(self, bid):
        """Maps internal biome ID to WorldPainter Biome constant name."""
        # Deprecated / Unused now
        return str(bid)

    def generate_script(self, heightmap_path, output_world_path, metadata_dict, **kwargs):
        """Generates the WorldPainter Javascript to build the world."""
        mp = self.config['minecraft']
        scale = mp['scale']['scale_percent']
        sea_level = mp['sea_level']
        
        # Build Limits
        min_build = mp['build_limit']['min']
        max_build = mp['build_limit']['max']
        
        # Note on Sea Level:
        # The heightmap.png is now generated by geospatial.py using "Smart Scaling" 
        # which ensures that 0m (Sea Level) maps exactly to Y = 62, and the Land Peak 
        # maps to Y = 320 (Max Build). The image range 0-65535 corresponds to 
        # [min_build, max_build] in block coordinates.
        # So we can simply map 0->min_build and 65535->max_build.
        
        abs_hm = self._to_wp_path(heightmap_path)
        abs_out = self._to_wp_path(output_world_path)
        
        # Build JS lines
        lines = [
            "// Auto-generated by map2craft",
            # Standard WorldPainter context is available as 'wp'

            f"print('Heightmap: {abs_hm}');",
            f"var heightMap = wp.getHeightMap().fromFile('{abs_hm}').go();",
            f"var mapFormat = wp.getMapFormat().withId('org.pepsoft.anvil.{mp['version']}').go();",
            
            # Create world with all settings in one statement
            f"var world = wp.createWorld().fromHeightMap(heightMap).scale({scale}).fromLevels(0, 65535).toLevels({min_build}, {max_build}).withWaterLevel({sea_level}).withMapFormat(mapFormat).withLowerBuildLimit({min_build}).withUpperBuildLimit({max_build}).go();"
        ]

        # First, apply a base terrain layer (Grass) to override WorldPainter's automatic terrain
        # This ensures we have full control over terrain types
        lines.append("print('Applying base terrain (Grass)...');")
        lines.append(f"wp.applyHeightMap(heightMap).toWorld(world).applyToTerrain().fromLevels(0, 65535).toTerrain(1).go();")

        # 1. Apply Terrain Types using Masks
        # Water Mask -> Sand (ID 5)
        water_mask = kwargs.get('water_mask')
        if water_mask:
            lines.append(f"print('Applying water mask (Sand)...');")
            lines.append(f"var waterMask = wp.getHeightMap().fromFile('{self._to_wp_path(water_mask)}').go();")
            lines.append(f"wp.applyHeightMap(waterMask).toWorld(world).applyToTerrain().fromLevel(255).toTerrain(5).go();")

        # Slope Mask -> Stone (ID 28)
        slope_mask = kwargs.get('slope_mask')
        if slope_mask:
            lines.append(f"print('Applying slope mask (Stone)...');")
            lines.append(f"var slopeMask = wp.getHeightMap().fromFile('{self._to_wp_path(slope_mask)}').go();")
            lines.append(f"wp.applyHeightMap(slopeMask).toWorld(world).applyToTerrain().fromLevel(255).toTerrain(28).go();")
        
        # Road Mask -> Coarse Dirt (ID 3)
        road_mask = kwargs.get('road_mask')
        if road_mask:
             lines.append(f"print('Applying roads (Coarse Dirt)...');")
             lines.append(f"var roadMask = wp.getHeightMap().fromFile('{self._to_wp_path(road_mask)}').go();")
             lines.append(f"wp.applyHeightMap(roadMask).toWorld(world).applyToTerrain().fromLevel(255).toTerrain(3).go();")

        # 2. Apply Biomes & Biome-Specific Terrain
        biomes_dict = kwargs.get('biomes', {})
        if biomes_dict:
            lines.append(f"print('Loading Biomes layer...');")
            lines.append(f"var biomesLayer = wp.getLayer().withName('Biomes').go();")
            
            # Define specific terrain mapping for biomes
            # ID: Target Terrain ID
            biome_terrain_map = {
                0: 0,    # Ocean -> Gravel Ocean Floor
                24: 0,   # Deep Ocean -> Gravel Ocean Floor
                45: 1,   # Lukewarm Ocean -> Sandy Ocean Floor
                16: 5,   # Beach -> Sand
                25: 28,  # Stone Shore -> Stone
                37: 6,   # Badlands -> Red Sand
                # 2: 1,    # Desert -> Sand (if present)
            }
            
            for bid, mask_path in biomes_dict.items():
                lines.append(f"print('Applying biome ID: {bid}...');")
                lines.append(f"var biomeMask = wp.getHeightMap().fromFile('{self._to_wp_path(mask_path)}').go();")
                
                # Apply to Biome Layer
                lines.append(f"wp.applyHeightMap(biomeMask).toWorld(world).applyToLayer(biomesLayer).fromLevel(255).toLevel({bid}).go();")
                
                # Apply to Terrain if matches
                if bid in biome_terrain_map:
                    target_terrain = biome_terrain_map[bid]
                    lines.append(f"// Also painting terrain {target_terrain} for biome {bid}")
                    lines.append(f"wp.applyHeightMap(biomeMask).toWorld(world).applyToTerrain().fromLevel(255).toTerrain({target_terrain}).go();")

        lines.extend([
            f"wp.saveWorld(world).toFile('{abs_out}').go();",
            "print('Done!');"
        ])
        
        return "\n".join(lines)

    def run_worldpainter(self, script_path):
        """Executes the WorldPainter JS script via wpscript executable."""
        wp_dir = self.config['worldpainter']['path']
        exe = Path(wp_dir)/'wpscript.exe' if os.name == 'nt' else Path('wpscript')
        
        # Fallback to system PATH if config path is invalid
        cmd = [str(exe) if exe.exists() else 'wpscript', script_path]
        
        log.info(f"Running WorldPainter: {cmd[0]}")
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            if result.stdout: log.info(f"WorldPainter output: {result.stdout}")
        except subprocess.CalledProcessError as e:
            log.error(f"WorldPainter execution failed: {e}")
            if e.stdout: log.error(f"stdout: {e.stdout}")
            if e.stderr: log.error(f"stderr: {e.stderr}")
            raise

    def world_action(self, target, source, env):
        """SCons action for world generation."""
        import json
        
        heightmap = str(source[0])
        meta_json_path = str(source[1])
        
        # Load Metadata
        metadata_dict = {}
        if os.path.exists(meta_json_path):
            with open(meta_json_path, 'r', encoding='utf-8') as f:
                metadata_dict = json.load(f)
        
        def get_src(i): return str(source[i]) if len(source) > i and str(source[i]) != 'None' else None
        
        water_mask = get_src(2)
        slope_mask = get_src(3)
        road_mask = get_src(4)
        biome_map = get_src(5)

        # Split biomes
        biomes_dict = {}
        if biome_map:
            log.info(f"Splitting biomes from {biome_map}...")
            out_dir = Path(str(target[0])).parent / "biome_masks"
            out_dir.mkdir(parents=True, exist_ok=True)
            biomes_dict = self.split_biomes(biome_map, out_dir)

        script_content = self.generate_script(
            heightmap, target[0],
            metadata_dict=metadata_dict,
            water_mask=water_mask,
            slope_mask=slope_mask,
            road_mask=road_mask,
            biomes=biomes_dict
        )
        
        script_file = str(target[1])
        Path(script_file).write_text(script_content)
        self.run_worldpainter(script_file)

    def export_action(self, target, source, env):
        """SCons action to export .world file to Minecraft save directory."""
        world_path = self._to_wp_path(source[0])
        out_dir = self._to_wp_path(Path(str(target[0])).parent)
        script_path = Path(str(target[0])).parent / "export_script.js"

        script = (
            "var wp = org.pepsoft.worldpainter.WorldPainter;\n"
            f"var world = wp.getWorld().fromFile('{world_path}').go();\n"
            f"wp.exportWorld(world).toDirectory('{out_dir}').go();\n"
            "print('Export complete!');"
        )
        
        script_path.write_text(script)
        self.run_worldpainter(str(script_path))

    